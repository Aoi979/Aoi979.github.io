<h1 id="leveldb-">LevelDB笔记</h1>
<blockquote>
<p>[!IMPORTANT]</p>
<p>阅读所需基础知识: </p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Log-structured_merge-tree">LSM-Tree</a></li>
<li><a href="https://oi-wiki.org/ds/skiplist/">SkipList</a></li>
</ul>
</blockquote>
<p>[TOC]</p>
<h2 id="-">核心接口分析</h2>
<p>db_impl.cc</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Status DBImpl::Write(const WriteOptions&amp; options, WriteBatch* updates)</strong></td>
<td>将需要存储的kv对写入</td>
<td>初始化一个writer,持有mutex，为writer设置需要写入的KV对以及任务的状态信息，此后上锁，将自身加入writers队列，这是等待写入的任务队列，writer若是非完成状态且不是队列的最前端那么将进入等待，至此这个写任务正式开始处理，通过MakeRoomForWrite函数检查memTable的状态，处理时尝试将当前写任务和正在等待的写任务合并处理，处理完这步就释放锁，把数据写入Log,随后写入memTable,此刻其他写任务也能正常进入任务队列，随后又上锁，开始处理错误以及其他所需的元信息，此时数据已经写入memTable，只需要把刚才批量处理掉的任务以及自身移出任务队列即可，此时若队列非空，那就唤醒头部的任务（writer）</td>
</tr>
<tr>
<td><strong>Status DBImpl::MakeRoomForWrite(bool force) </strong></td>
<td>确保memTable能正常使用</td>
<td>开始<br/>├─ 1. 是否有后台错误？ → 返回错误<br/>│<br/>├─ 2. L0 文件数是否触发了写入减速？ → 延迟 1ms<br/>│<br/>├─ 3. 当前内存表是否有空间？ → 允许写入<br/>│<br/>├─ 4. 是否有未完成的不可变内存表（imm_）压缩？ → 等待压缩完成<br/>│<br/>├─ 5. L0 文件数是否触发了停止写入？ → 等待压缩完成<br/>│<br/>└─ 6. 其他情况 → 切换内存表 + 触发压缩</td>
</tr>
<tr>
<td><strong>Status DBImpl::Get(const ReadOptions&amp; options, const Slice&amp; key,std::string* value) </strong></td>
<td>读取KV</td>
<td>尝试在memTable，immuMemTable,SSTable读,若在SSTable读需要更新统计信息，同时读取的统计信息可能会触发压缩条件，所以需要尝试压缩</td>
</tr>
</tbody>
</table>
<h2 id="memtable-">MemTable 实现分析</h2>
<p>MemTable的实现依赖于SkipList,这是一种媲美红黑树的数据结构</p>
<p>下面给出一个简单的实现</p>
<pre><code class="lang-cpp"><span class="hljs-keyword">class</span> Skiplist {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">struct</span> Node {
        <span class="hljs-keyword">int</span> value;
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Node *&gt; forward;    
        Node(<span class="hljs-keyword">int</span> value, <span class="hljs-keyword">int</span> level) : value(value), forward(level, <span class="hljs-literal">nullptr</span>) {}
};

Skiplist() {
    srand(time(<span class="hljs-number">0</span>));
    max_level = <span class="hljs-number">4</span>;
    header = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">-1</span>, max_level);
    level = <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span> </span>{
    Node *current = header;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = level; i &gt;= <span class="hljs-number">0</span>; --i) {
        <span class="hljs-keyword">while</span> (current-&gt;forward[i] != <span class="hljs-literal">nullptr</span> &amp;&amp;
               current-&gt;forward[i]-&gt;value &lt; target) {
            current = current-&gt;forward[i];
        }
        <span class="hljs-keyword">if</span> (current-&gt;forward[i] != <span class="hljs-literal">nullptr</span> &amp;&amp;
            current-&gt;forward[i]-&gt;value == target) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>{
    Node *current = header;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Node *&gt; <span class="hljs-built_in">list</span>(max_level, <span class="hljs-literal">nullptr</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = level; i &gt;= <span class="hljs-number">0</span>; --i) {
        <span class="hljs-keyword">while</span> (current-&gt;forward[i] != <span class="hljs-literal">nullptr</span> &amp;&amp;
               current-&gt;forward[i]-&gt;value &lt; num) {
            current = current-&gt;forward[i];
        }
        <span class="hljs-built_in">list</span>[i] = current-&gt;forward[i];
    }
    <span class="hljs-keyword">int</span> node_lv = randomLevel();
    <span class="hljs-keyword">if</span> (node_lv &gt; level) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = level + <span class="hljs-number">1</span>; i &lt;= node_lv; i++) {
            <span class="hljs-built_in">list</span>[i] = header-&gt;forward[i];
        }
        level = node_lv;
    }
    Node *new_node = <span class="hljs-keyword">new</span> Node(num, node_lv + <span class="hljs-number">1</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= node_lv; i++) {
        new_node-&gt;forward[i] = <span class="hljs-built_in">list</span>[i];
        <span class="hljs-built_in">list</span>[i] = new_node;
    }
}

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Node *&gt; update(max_level, <span class="hljs-literal">nullptr</span>);
    Node *current = header;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = level; i &gt;= <span class="hljs-number">0</span>; --i) {
        <span class="hljs-keyword">while</span> (current-&gt;forward[i] != <span class="hljs-literal">nullptr</span> &amp;&amp;
               current-&gt;forward[i]-&gt;value &lt; num) {
            current = current-&gt;forward[i];
        }
        update[i] = current;
    }

    current = current-&gt;forward[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">if</span> (current != <span class="hljs-literal">nullptr</span> &amp;&amp; current-&gt;value == num) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= level; ++i) {
            <span class="hljs-keyword">if</span> (update[i]-&gt;forward[i] != current) {
                <span class="hljs-keyword">break</span>;
            }
            update[i]-&gt;forward[i] = current-&gt;forward[i];
        }

        <span class="hljs-keyword">delete</span> current; 
        <span class="hljs-keyword">while</span> (level &gt; <span class="hljs-number">0</span> &amp;&amp; header-&gt;forward[level] == <span class="hljs-literal">nullptr</span>) {
            --level;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; 
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">randomLevel</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> lv = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (rand() % <span class="hljs-number">2</span> &amp;&amp; lv &lt; max_level - <span class="hljs-number">1</span>) {
        lv++;
    }
    <span class="hljs-keyword">return</span> lv;
}
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> level;
    <span class="hljs-keyword">int</span> max_level;
    Node *header;
};
</code></pre>
<h3 id="-">编码格式</h3>
<table>
<thead>
<tr>
<th>key_len</th>
<th>key</th>
<th>tag</th>
<th>value_len</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p><strong>tag = sequence(7B) + ValueType(1B)</strong></p>
<p>都使用varint编码</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>具体描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>void MemTable::Add(SequenceNumber s, ValueType type, const Slice&amp; key, const Slice&amp; value) </strong></td>
<td>写入数据到memTable</td>
<td>编码并插入跳表</td>
</tr>
<tr>
<td><strong>bool MemTable::Get(const LookupKey&amp; key, std::string<em> value, Status</em> s)</strong></td>
<td>查询</td>
<td>通过内部跳表初始化一个迭代器，在跳表中查找，找到后再根据写入的格式进行解码，最后根据数据的tag判断，如果数据是删除状态的就返回不存在</td>
</tr>
</tbody>
</table>
<h2 id="wal-">WAL日志分析</h2>
<p>日志文件数据按32KB固定大小的Block写入，写入的数据称为Record</p>
<h3 id="-">编码格式</h3>
<table>
<thead>
<tr>
<th>Header</th>
<th>Raw</th>
</tr>
</thead>
<tbody>
<tr>
<td>checksum  4B   \</td>
<td>length  2B</td>
<td>type  1B \</td>
<td>data    length B</td>
</tr>
</tbody>
</table>
<p>当遇到的内容非常大的数据，或者当前的Block剩余空间不足以存储当前要存储的数据时，会先将该数据进行分段，然后组织成多条Record存入多个Block中，为了标识Record的类型引入了type,他是一个枚举类型</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>value</th>
<th>note</th>
</tr>
</thead>
<tbody>
<tr>
<td>kFullType</td>
<td>1</td>
<td>表示该Record完整存储在当前block中</td>
</tr>
<tr>
<td>kFirstType</td>
<td>2</td>
<td>表示为第一个分段</td>
</tr>
<tr>
<td>kMiddleType</td>
<td>3</td>
<td>表示为中间分段</td>
</tr>
<tr>
<td>kLastType</td>
<td>4</td>
<td>表示为最后一个分段</td>
</tr>
</tbody>
</table>
<p>Writer用来追加写入数据，Reader在启动后调用，通过从WAL日志中读取数据来尝试恢复之前内存中可能丢失的数据</p>
<h3 id="writer-">Writer的实现</h3>
<p>WAL日志通过这个结构对外提供AddRecord(data)的接口，负责编码和写入文件</p>
<pre><code class="lang-cpp">Status Writer::AddRecord(const Slice&amp; slice) {
  const char* ptr = slice.data();
  size_t left = slice.size();

  <span class="hljs-comment">// Fragment the record if necessary and emit it.  Note that if slice</span>
  <span class="hljs-comment">// is empty, we still want to iterate once to emit a single</span>
  <span class="hljs-comment">// zero-length record</span>
  Status s;
  bool <span class="hljs-keyword">begin</span> = <span class="hljs-keyword">true</span>;
  <span class="hljs-keyword">do</span> {
    const int leftover = kBlockSize - block_offset_;
    <span class="hljs-keyword">assert</span>(leftover &gt;= <span class="hljs-number">0</span>);
    <span class="hljs-keyword">if</span> (leftover &lt; kHeaderSize) {
      <span class="hljs-comment">// Switch to a new block</span>
      <span class="hljs-keyword">if</span> (leftover &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// Fill the trailer (literal below relies on kHeaderSize being 7)</span>
        static_assert(kHeaderSize == <span class="hljs-number">7</span>, <span class="hljs-string">""</span>);
        dest_-&gt;Append(Slice(<span class="hljs-string">"\x00\x00\x00\x00\x00\x00"</span>, leftover));
      }
      block_offset_ = <span class="hljs-number">0</span>;
    }

    <span class="hljs-comment">// Invariant: we never leave &lt; kHeaderSize bytes in a block.</span>
    <span class="hljs-keyword">assert</span>(kBlockSize - block_offset_ - kHeaderSize &gt;= <span class="hljs-number">0</span>);

    const size_t avail = kBlockSize - block_offset_ - kHeaderSize;
    const size_t fragment_length = (left &lt; avail) ? left : avail;

    RecordType <span class="hljs-class"><span class="hljs-keyword">type</span>;</span>
    <span class="hljs-comment">//如果当前段的长度和待写入数据的剩余长度相等，说明是最后一个record</span>
    const bool <span class="hljs-keyword">end</span> = (left == fragment_length);
      <span class="hljs-comment">//如果begin和end都为true,说明一次就能写完</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">begin</span> &amp;&amp; <span class="hljs-keyword">end</span>) {
      <span class="hljs-class"><span class="hljs-keyword">type</span> </span>= kFullType;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">begin</span>) {
        <span class="hljs-comment">//当前是第一段</span>
      <span class="hljs-class"><span class="hljs-keyword">type</span> </span>= kFirstType;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">end</span>) {
        <span class="hljs-comment">//当前是最后段</span>
      <span class="hljs-class"><span class="hljs-keyword">type</span> </span>= kLastType;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">//是中间段</span>
      <span class="hljs-class"><span class="hljs-keyword">type</span> </span>= kMiddleType;
    }
      <span class="hljs-comment">//将ptr~ptr+fragment_length写入log</span>
    s = EmitPhysicalRecord(<span class="hljs-class"><span class="hljs-keyword">type</span>, <span class="hljs-title">ptr</span>, <span class="hljs-title">fragment_length</span>);</span>
      <span class="hljs-comment">//更新指针</span>
    ptr += fragment_length;
    left -= fragment_length;
    <span class="hljs-keyword">begin</span> = <span class="hljs-keyword">false</span>;
  } <span class="hljs-keyword">while</span> (s.ok() &amp;&amp; left &gt; <span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> s;
}
</code></pre>
<p>没啥好介绍的，下面是写入逻辑，通过dest_的append和flush完成</p>
<pre><code class="lang-cpp">Status Writer::EmitPhysicalRecord(RecordType t, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ptr,
                                  <span class="hljs-keyword">size_t</span> length) {
  assert(length &lt;= <span class="hljs-number">0xffff</span>);  <span class="hljs-comment">// Must fit in two bytes</span>
  assert(block_offset_ + kHeaderSize + length &lt;= kBlockSize);

  <span class="hljs-comment">// Format the header</span>
  <span class="hljs-keyword">char</span> buf[kHeaderSize];
  buf[<span class="hljs-number">4</span>] = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">char</span>&gt;(length &amp; <span class="hljs-number">0xff</span>);
  buf[<span class="hljs-number">5</span>] = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">char</span>&gt;(length &gt;&gt; <span class="hljs-number">8</span>);
  buf[<span class="hljs-number">6</span>] = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">char</span>&gt;(t);

  <span class="hljs-comment">// Compute the crc of the record type and the payload.</span>
  <span class="hljs-keyword">uint32_t</span> crc = crc32c::Extend(type_crc_[t], ptr, length);
  crc = crc32c::Mask(crc);  <span class="hljs-comment">// Adjust for storage</span>
  EncodeFixed32(buf, crc);

  <span class="hljs-comment">// Write the header and the payload</span>
  Status s = dest_-&gt;Append(Slice(buf, kHeaderSize));
  <span class="hljs-keyword">if</span> (s.ok()) {
    s = dest_-&gt;Append(Slice(ptr, length));
    <span class="hljs-keyword">if</span> (s.ok()) {
      s = dest_-&gt;Flush();
    }
  }
  block_offset_ += kHeaderSize + length;
  <span class="hljs-keyword">return</span> s;
}
</code></pre>
<h3 id="writablefile-">WritableFile实现</h3>
<p>是顺序写文件的抽象结构</p>
<p>注意当调用Append(data)追加完数据以后，上层应用程序需要手动调用Flush()方法来触发缓冲区中的数据写入磁盘。同时LevelDB提供了处理写操作的WriteOptions参数，可选地设置参数sync的值。如果sync设置为true，那么写入WAL日志后还会同步调用WritableFile结构的Sync()方法确保数据一定写到磁盘上。因为系统默认数据会先写入操作系统的缓冲区，然后在将来的某个时刻，操作系统会将缓冲区中的数据刷到磁盘上。如果数据未刷到磁盘之前操作系统宕机了，那么数据仍然有丢失的风险。如果只是进程崩溃了，操作系统正常运行，则不会有风险。为了确保数据一定能写入磁盘，可以在调用LevelDB写入数据时将WriteOptions参数中的sync设置为true。</p>
<h3 id="reader-">Reader实现</h3>
<p>主要是ReadRecord(record)方法，分为二步，从文件以block为单位加载到buffer,解码数据，重建写入前的数据，如果是分段的那就合并</p>
<h2 id="sstable-">SSTable实现</h2>
<p>SSTable一般由Minor压缩和Major压缩生成，不管怎么样他都是只读文件，生成后不会改变，且他的数据是有序的，查询的时候需要使用这个性质</p>
<h3 id="sstable-">SSTable 结构</h3>
<table>
<thead>
<tr>
<th>Data Block1</th>
<th>数据</th>
<th>存储KV数据</th>
</tr>
</thead>
<tbody>
<tr>
<td>Data Block2</td>
<td>数据</td>
<td>存储kv数据</td>
</tr>
<tr>
<td>......</td>
<td>数据</td>
<td>存储kv数据</td>
</tr>
<tr>
<td>DataBlock n</td>
<td>数据</td>
<td>存储kv数据</td>
</tr>
<tr>
<td>Filter Block</td>
<td>数据</td>
<td>布隆过滤器</td>
</tr>
<tr>
<td>Meta Index Block</td>
<td>索引 -&gt; Filter Block</td>
<td>存储Filter Block的索引信息</td>
</tr>
<tr>
<td>Index Block</td>
<td>索引 -&gt; Data Block n</td>
<td>存储 Data Block的索引信息</td>
</tr>
<tr>
<td>Footer</td>
<td>索引 -&gt; Index Block \</td>
<td>Meta Index Block</td>
<td>存储 Meta Index Block 和 Index Block的索引信息</td>
</tr>
</tbody>
</table>
<h3 id="block-">Block结构</h3>
<p>每个Block默认大小为4KB,由数据，压缩类型，校验码组成，默认采用Snappy压缩算法</p>
<table>
<thead>
<tr>
<th>Data</th>
<th>CompressionType</th>
<th>CRC</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h3 id="datablock">DataBlock</h3>
<table>
<thead>
<tr>
<th>kv 1</th>
<th>kv数据</th>
</tr>
</thead>
<tbody>
<tr>
<td>kv 2</td>
<td>kv数据</td>
</tr>
<tr>
<td>......</td>
<td>kv数据</td>
</tr>
<tr>
<td>kv n</td>
<td>kv数据</td>
</tr>
<tr>
<td>restart offset 1(4)</td>
<td>重启点数据</td>
</tr>
<tr>
<td>restart offset 2(4)</td>
<td>重启点数据</td>
</tr>
<tr>
<td>......</td>
<td>重启点数据</td>
</tr>
<tr>
<td>restart offset m(4)</td>
<td>重启点数据</td>
</tr>
<tr>
<td>restart count(4)</td>
<td>重启点数据</td>
</tr>
<tr>
<td>Type(1)</td>
<td>压缩类型</td>
</tr>
<tr>
<td>CRC(4)</td>
<td>校验码</td>
</tr>
</tbody>
</table>
<p>在DataBlock中的KV数据如下</p>
<table>
<thead>
<tr>
<th>K的共享长度</th>
<th>K的未共享长度</th>
<th>V的长度</th>
<th>K的未共享内容</th>
<th>V的内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>shared_key_len</td>
<td>unshared_key_len</td>
<td>value_len</td>
<td>unshared key</td>
<td>value</td>
</tr>
</tbody>
</table>
<p>LevelDB中多条KV数据之间是按照K的顺序有序存储的，这意味着相邻的多条数据之间key的内容可能会存在相同部分，因此leveldb在存储每条kv数据时对k部分进行压缩，将key分为两部分：第一部分是当前的k和前一条kv的k重复的部分，第二部分是不重复部分。</p>
<p>这样操作，空间得到了优化，问题是获取一条完整的kv数据需要对k进行拼接，如果全部的kv数据都按照这个方式存储那么恢复k的过程很长，所以引入重启点这个概念。通过设定一个数据间隔，每隔几条数据就记录一个完整的k,然后再按照上述方式进行压缩，当达到间隔后再记录一次完整的k,不断重复</p>
<h3 id="-">重启点数据</h3>
<p>重启点数据由多个重启项和重启点个数两个部分组成，大小均为4B。每个重启项记录的是该条重启点的KV数据写入DataBlock中的位置。通过该重启点就可以直接读取该条KV数据的完整数据。位于两个重启点之间的数据在恢复的时候需要顺序遍历逐个恢复。重启点个数记录的就是当前DataBlock总共存储的重启点的个数。重启点间隔通过参数来配置，默认16,16条数据就要保存一个重启点，这是一个超参数</p>
<h3 id="index-block">Index Block</h3>
<p>一个SSTable中有多个Data Block存储kv数据，满了之后就需要打开另一个文件继续写，采用Index Block来完成对已满的Data Block进行索引，他和<strong><u>Data Block的结构完全一样</u></strong>，不难设想对Data Block索引信息为key--offset--length，key表示当前DataBlock保存的所有KV数据中K的最大值，offset和length表示该DataBlock写入SSTable的位置以及长度。实际上LevelDB索引信息的K是当前DataBlock的K的最大值（最后一个）和下一个DataBlock的k的最小值（第一个）的最短分隔符，这样的设计可以减少占用空间。V是经过BlockHandle结构编码后的内容，就是封装了前面的offset和length</p>
<h3 id="filter-block">Filter Block</h3>
<p>就是布隆过滤器，存在误判，发生误判概率为
$$
p = [1-(1-\frac{1}{m})^{kn}]^k \approx (1-e^{\frac{kn}{m}})^k
$$
m为位数组大小，n为元素数量，k为哈希函数个数，最优k如下
$$
当k=0.7\frac{m}{n}时误判率最低，p=f(k)=(1-e^{\frac{kn}{m}})^k=2^{-ln2\frac{m}{n}} \approx (0.6158)^{\frac{m}{n}}
$$
可以得到
$$
m=-\frac{nlnp}{{(ln2})^2}
$$
结构如下</p>
<table>
<thead>
<tr>
<th>filter 1</th>
<th>过滤器内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>filter 2</td>
<td>过滤器内容</td>
</tr>
<tr>
<td>......</td>
<td>过滤器内容</td>
</tr>
<tr>
<td>filter n</td>
<td>过滤器内容</td>
</tr>
<tr>
<td>filter offset 1(4)</td>
<td>过滤器偏移量</td>
</tr>
<tr>
<td>filter offset 2(4)</td>
<td>过滤器偏移量</td>
</tr>
<tr>
<td>......</td>
<td>过滤器偏移量</td>
</tr>
<tr>
<td>filter offset n(4)</td>
<td>过滤器偏移量</td>
</tr>
<tr>
<td>filter data size</td>
<td>过滤器元信息</td>
</tr>
<tr>
<td>filter base(1)</td>
<td>过滤器元信息</td>
</tr>
<tr>
<td>Type(1)</td>
<td>压缩类型</td>
</tr>
<tr>
<td>CRC(4)</td>
<td>检验码</td>
</tr>
</tbody>
</table>
<p>对于SSTable而言，每2kb的kv数据就会生成一个布隆过滤器，布隆过滤器的相关数据存入filter。过滤器偏移量记录每个过滤器内容写入的位置，根据前后两个过滤器的偏移量就可以获取对应的过滤器的内容，每个偏移量使用4B存储。过滤器元数据主要包含过滤器内容大小和过滤器基数，过滤器内容大小用4B存储，主要记录过滤器内容所占大小，过滤器基数在LevelDB中是一个常数11,代表2的11次方，即每2KB分配一个布隆过滤器</p>
<h3 id="meta-index-block">Meta Index Block</h3>
<p>当Filter Block写完后也需要记录其索引信息，该索引信息在SSTable中是采用Meta Index Block,以KV数据存储的，其<strong><u>和Data Block结构一致</u></strong>，Filter Block的索引信息中K为 “filter.&quot;加上布隆过滤器的名字。V也是一个Block Handle结构，存储Filter Block在SSTable中写入的位置和长度。通过这个可以得到Filter Block的完整内容</p>
<h3 id="footer">Footer</h3>
<p>结构如下</p>
<table>
<thead>
<tr>
<th>Meta Index Block 的索引</th>
</tr>
</thead>
<tbody>
<tr>
<td>Index Block 的索引</td>
</tr>
<tr>
<td>Padding 填充</td>
</tr>
<tr>
<td>Magic 魔数</td>
</tr>
</tbody>
</table>
<h2 id="block-">Block的写入</h2>
<p>从上面可以得知，只有Filter Block的结构和其他Block不同，所以对于Filter Block他的读写需要单独的Builder，这里分为FilterBlockBuilder和BlockBuilder,读取则是FilterBlockReader和Block::Iter</p>
<h3 id="blockbuilder-">BlockBuilder结构</h3>
<p>table/block_builder.cc</p>
<p>核心函数</p>
<table>
<thead>
<tr>
<th>void BlockBuilder::Add(const Slice&amp; key, const Slice&amp; value)</th>
<th>添加KV数据</th>
</tr>
</thead>
<tbody>
<tr>
<td>Slice BlockBuilder::Finish()</td>
<td>返回完整Block</td>
</tr>
</tbody>
</table>
<pre><code class="lang-c++"><span class="hljs-keyword">void</span> BlockBuilder::Add(<span class="hljs-keyword">const</span> Slice&amp; <span class="hljs-built_in">key</span>, <span class="hljs-keyword">const</span> Slice&amp; value) {
  Slice last_key_piece(last_key_);
  <span class="hljs-keyword">assert</span>(!finished_);<span class="hljs-comment">// 确保未调用 Finish()</span>
  <span class="hljs-keyword">assert</span>(counter_ &lt;= options_-&gt;block_restart_interval);
  <span class="hljs-keyword">assert</span>(buffer_.empty()  <span class="hljs-comment">// No values yet?</span>
         || options_-&gt;comparator-&gt;Compare(<span class="hljs-built_in">key</span>, last_key_piece) &gt; <span class="hljs-number">0</span>);<span class="hljs-comment">// 保证有序</span>
  size_t shared = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">if</span> (counter_ &lt; options_-&gt;block_restart_interval) {
    <span class="hljs-comment">// See how much sharing to do with previous string</span>
    <span class="hljs-comment">// 计算当前 key 与前一个 key 的共享前缀长度</span>
    <span class="hljs-keyword">const</span> size_t min_length = std::<span class="hljs-built_in">min</span>(last_key_piece.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">key</span>.<span class="hljs-built_in">size</span>());
    <span class="hljs-keyword">while</span> ((shared &lt; min_length) &amp;&amp; (last_key_piece[shared] == <span class="hljs-built_in">key</span>[shared])) {
      shared++;
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 达到重启间隔，记录重启点并重置计数器</span>
    <span class="hljs-comment">// Restart compression</span>
    restarts_.push_back(buffer_.<span class="hljs-built_in">size</span>());
    counter_ = <span class="hljs-number">0</span>;
  }
  <span class="hljs-keyword">const</span> size_t non_shared = <span class="hljs-built_in">key</span>.<span class="hljs-built_in">size</span>() - shared;

  <span class="hljs-comment">// Add "&lt;shared&gt;&lt;non_shared&gt;&lt;value_size&gt;" to buffer_</span>
  PutVarint32(&amp;buffer_, shared);
  PutVarint32(&amp;buffer_, non_shared);
  PutVarint32(&amp;buffer_, value.<span class="hljs-built_in">size</span>());

  <span class="hljs-comment">// Add string delta to buffer_ followed by value</span>
  buffer_.<span class="hljs-built_in">append</span>(<span class="hljs-built_in">key</span>.data() + shared, non_shared);
  buffer_.<span class="hljs-built_in">append</span>(value.data(), value.<span class="hljs-built_in">size</span>());

  <span class="hljs-comment">// Update state</span>
  last_key_.resize(shared);
  last_key_.<span class="hljs-built_in">append</span>(<span class="hljs-built_in">key</span>.data() + shared, non_shared);
  <span class="hljs-comment">// 更新 last_key_ 为当前 key</span>
  <span class="hljs-keyword">assert</span>(Slice(last_key_) == <span class="hljs-built_in">key</span>);
  counter_++;
}
<span class="hljs-comment">//添加重启点数据进Block</span>
Slice BlockBuilder::Finish() {
  <span class="hljs-comment">// Append restart array</span>
  <span class="hljs-keyword">for</span> (size_t i = <span class="hljs-number">0</span>; i &lt; restarts_.<span class="hljs-built_in">size</span>(); i++) {
    PutFixed32(&amp;buffer_, restarts_[i]);
  }
  PutFixed32(&amp;buffer_, restarts_.<span class="hljs-built_in">size</span>());
  finished_ = <span class="hljs-keyword">true</span>;
  <span class="hljs-keyword">return</span> Slice(buffer_);
}
</code></pre>
<h3 id="filterblockbuilder-">FilterBlockBuilder结构</h3>
<p>table/filter_block.cc</p>
<p>成员变量</p>
<table>
<thead>
<tr>
<th style="text-align:center">变量名</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>policy_</strong></td>
<td style="text-align:center">const FilterPolicy*</td>
<td style="text-align:center">指向<strong>过滤器策略</strong>的指针（如 Bloom Filter 的具体实现），负责创建和检查过滤器。</td>
</tr>
<tr>
<td style="text-align:center"><strong>keys_</strong></td>
<td style="text-align:center">std::string</td>
<td style="text-align:center"><strong>扁平化存储所有键的字符串</strong>，例如将多个键连续存储为 <code>&quot;key1key2key3...&quot;</code>。</td>
</tr>
<tr>
<td style="text-align:center"><strong>start_</strong></td>
<td style="text-align:center">std::vector<size_t></td>
<td style="text-align:center">记录每个键在 <code>keys_</code> 中的<strong>起始位置索引</strong>，用于快速定位键内容（例如 <code>start_ = [0, 4, 8]</code> 表示三个键分别从 0、4、8 字节开始）。</td>
</tr>
<tr>
<td style="text-align:center"><strong>result_</strong></td>
<td style="text-align:center">std::string</td>
<td style="text-align:center"><strong>最终生成的 Filter Block 数据</strong>，包含所有过滤器二进制内容及元数据。</td>
</tr>
<tr>
<td style="text-align:center"><strong>tmp<em>keys</em></strong></td>
<td style="text-align:center">std::vector<Slice></td>
<td style="text-align:center">临时存储当前数据块的键集合，用于调用 <code>policy_-&gt;CreateFilter()</code> 生成单个过滤器。</td>
</tr>
<tr>
<td style="text-align:center"><strong>filter<em>offsets</em></strong></td>
<td style="text-align:center">std::vector<uint32_t></td>
<td style="text-align:center">记录每个过滤器在 <code>result_</code> 中的<strong>偏移量</strong>（起始位置），用于快速定位特定数据块的过滤器。</td>
</tr>
</tbody>
</table>
<p>核心函数</p>
<table>
<thead>
<tr>
<th>void StartBlock(uint64_t block_offset)</th>
<th>初始化</th>
</tr>
</thead>
<tbody>
<tr>
<td>void AddKey(const Slice&amp; key)</td>
<td>添加Key</td>
</tr>
<tr>
<td>Slice Finish();</td>
<td>完成</td>
</tr>
<tr>
<td>void GenerateFilter()</td>
<td>生成过滤器</td>
</tr>
</tbody>
</table>
<pre><code class="lang-cpp"><span class="hljs-keyword">void</span> FilterBlockBuilder::StartBlock(uint64_t block_offset) {
  uint64_t filter_index = (block_offset / kFilterBase);
  assert(filter_index &gt;= filter_offsets_.<span class="hljs-built_in">size</span>());
  <span class="hljs-built_in">while</span> (filter_index &gt; filter_offsets_.<span class="hljs-built_in">size</span>()) {
    GenerateFilter();
  }
}

<span class="hljs-keyword">void</span> FilterBlockBuilder::AddKey(<span class="hljs-keyword">const</span> Slice&amp; key) {
  Slice k = key;
  start_.push_back(keys_.<span class="hljs-built_in">size</span>());
  keys_.append(k.data(), k.<span class="hljs-built_in">size</span>());
}

Slice FilterBlockBuilder::Finish() {
  <span class="hljs-built_in">if</span> (!start_.empty()) {
    GenerateFilter();
  }

  <span class="hljs-comment">// Append array of per-filter offsets</span>
  <span class="hljs-keyword">const</span> uint32_t array_offset = result_.<span class="hljs-built_in">size</span>();
  <span class="hljs-built_in">for</span> (size_t i = <span class="hljs-number">0</span>; i &lt; filter_offsets_.<span class="hljs-built_in">size</span>(); i++) {
    PutFixed32(&amp;result_, filter_offsets_[i]);
  }

  PutFixed32(&amp;result_, array_offset);
  result_.push_back(kFilterBaseLg);  <span class="hljs-comment">// Save encoding parameter in result</span>
  <span class="hljs-built_in">return</span> Slice(result_);
}

<span class="hljs-keyword">void</span> FilterBlockBuilder::GenerateFilter() {
  <span class="hljs-keyword">const</span> size_t num_keys = start_.<span class="hljs-built_in">size</span>();
  <span class="hljs-built_in">if</span> (num_keys == <span class="hljs-number">0</span>) {
    <span class="hljs-comment">// Fast path if there are no keys for this filter</span>
    filter_offsets_.push_back(result_.<span class="hljs-built_in">size</span>());
    <span class="hljs-built_in">return</span>;
  }

  <span class="hljs-comment">// Make list of keys from flattened key structure</span>
  start_.push_back(keys_.<span class="hljs-built_in">size</span>());  <span class="hljs-comment">// Simplify length computation</span>
  tmp_keys_.resize(num_keys);
  <span class="hljs-built_in">for</span> (size_t i = <span class="hljs-number">0</span>; i &lt; num_keys; i++) {
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* base = keys_.data() + start_[i];
    size_t length = start_[i + <span class="hljs-number">1</span>] - start_[i];
    tmp_keys_[i] = Slice(base, length);
  }

  <span class="hljs-comment">// Generate filter for current set of keys and append to result_.</span>
  filter_offsets_.push_back(result_.<span class="hljs-built_in">size</span>());
  policy_-&gt;CreateFilter(&amp;tmp_keys_[<span class="hljs-number">0</span>], <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(num_keys), &amp;result_);

  tmp_keys_.<span class="hljs-built_in">clear</span>();
  keys_.<span class="hljs-built_in">clear</span>();
  start_.<span class="hljs-built_in">clear</span>();
}
</code></pre>
<p>前面提到每2k需要一个Filter,这反应在  <code>uint64_t filter_index = (block_offset / kFilterBase)</code>其中kFilterBase就是2048,计算得到当前数据的FilterIndex大于filter数量时那就创建新的Filter,在向SSTable中添加数据时会同步调用FilterBlockBuilder的Add方法来设置Filter,添加的Key会扁平化存储在keys中，同时在starts中存储索引信息。当一个SSTable写满后会调用Finish生成一个DataBlock,同时也会同步调用Filter的Finsh将布隆过滤器的数据写入FilterBlock。过滤器的创建在bloom.cc文件中，跳过不讲了。</p>
<h3 id="block-filterblockreade-">Block结构和FilterBlockReade结构</h3>
<h4 id="block-">Block结构</h4>
<p>SSTable中每个Block读取出来后通过Block结构来存储，而读取是通过Block::Iter迭代器实现的。</p>
<p>成员变量</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>变量名</strong></th>
<th style="text-align:center"><strong>类型</strong></th>
<th style="text-align:center"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">data_</td>
<td style="text-align:center">const char*</td>
<td style="text-align:center">指向块数据的指针，存储实际内容（不可修改）</td>
</tr>
<tr>
<td style="text-align:center">size_</td>
<td style="text-align:center">size_t</td>
<td style="text-align:center">块数据的实际大小（字节）</td>
</tr>
<tr>
<td style="text-align:center">restart<em>offset</em></td>
<td style="text-align:center">uint32_t</td>
<td style="text-align:center">块内重启点（Restart Point）数组在 data_中的偏移量，用于快速定位</td>
</tr>
<tr>
<td style="text-align:center">owned_</td>
<td style="text-align:center">bool</td>
<td style="text-align:center">标记 Block 是否拥有 data_ 的内存所有权，控制析构时是否释放资源</td>
</tr>
</tbody>
</table>
<pre><code class="lang-c++">Block::Block(<span class="hljs-keyword">const</span> BlockContents&amp; contents)
    : data_(contents.data.data()),
      size_(contents.data.size()),
      owned_(contents.heap_allocated) {
  <span class="hljs-keyword">if</span> (size_ &lt; <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint32_t</span>)) {
    size_ = <span class="hljs-number">0</span>;  <span class="hljs-comment">// Error marker</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">size_t</span> max_restarts_allowed = (size_ - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint32_t</span>)) / <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint32_t</span>);
    <span class="hljs-keyword">if</span> (NumRestarts() &gt; max_restarts_allowed) {
      <span class="hljs-comment">// The size is too small for NumRestarts()</span>
      size_ = <span class="hljs-number">0</span>;
    } <span class="hljs-keyword">else</span> {
      restart_offset_ = size_ - (<span class="hljs-number">1</span> + NumRestarts()) * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint32_t</span>);
    }
  }
}
</code></pre>
<p>先进行基本校验，DataBlock末尾必须存储一个重启点数据大小（uint32_t），再验证重启点数量合法性和计算重启点数组偏移量。</p>
<pre><code class="lang-cpp"><span class="hljs-comment">// Helper routine: decode the next block entry starting at "p",</span>
<span class="hljs-comment">// storing the number of shared key bytes, non_shared key bytes,</span>
<span class="hljs-comment">// and the length of the value in "*shared", "*non_shared", and</span>
<span class="hljs-comment">// "*value_length", respectively.  Will not dereference past "limit".</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// If any errors are detected, returns nullptr.  Otherwise, returns a</span>
<span class="hljs-comment">// pointer to the key delta (just past the three decoded values).</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-title">DecodeEntry</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* p, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* limit,
                                      <span class="hljs-keyword">uint32_t</span>* shared, <span class="hljs-keyword">uint32_t</span>* non_shared,
                                      <span class="hljs-keyword">uint32_t</span>* value_length)</span> </span>{
  <span class="hljs-keyword">if</span> (limit - p &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
  *shared = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span>*&gt;(p)[<span class="hljs-number">0</span>];
  *non_shared = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span>*&gt;(p)[<span class="hljs-number">1</span>];
  *value_length = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span>*&gt;(p)[<span class="hljs-number">2</span>];
  <span class="hljs-keyword">if</span> ((*shared | *non_shared | *value_length) &lt; <span class="hljs-number">128</span>) {
    <span class="hljs-comment">// Fast path: all three values are encoded in one byte each</span>
    p += <span class="hljs-number">3</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">if</span> ((p = GetVarint32Ptr(p, limit, shared)) == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
    <span class="hljs-keyword">if</span> ((p = GetVarint32Ptr(p, limit, non_shared)) == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
    <span class="hljs-keyword">if</span> ((p = GetVarint32Ptr(p, limit, value_length)) == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
  }

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(limit - p) &lt; (*non_shared + *value_length)) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
  }
  <span class="hljs-keyword">return</span> p;
}
</code></pre>
<p>从p位置开始解析entry的shared,non_shared,value_length等信息</p>
<p>Block通过迭代器来读取，在Block中进行查找时，主要通过Block::Iter的Seek方法完成</p>
<pre><code class="lang-cpp">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Slice&amp; target)</span> override </span>{
    <span class="hljs-comment">// Binary search in restart array to find the last restart point</span>
    <span class="hljs-comment">// with a key &lt; target</span>
    <span class="hljs-keyword">uint32_t</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">uint32_t</span> right = num_restarts_ - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> current_key_compare = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">if</span> (Valid()) {
      <span class="hljs-comment">// If we're already scanning, use the current position as a starting</span>
      <span class="hljs-comment">// point. This is beneficial if the key we're seeking to is ahead of the</span>
      <span class="hljs-comment">// current position.</span>
      current_key_compare = Compare(key_, target);
      <span class="hljs-keyword">if</span> (current_key_compare &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// key_ is smaller than target</span>
        left = restart_index_;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current_key_compare &gt; <span class="hljs-number">0</span>) {
        right = restart_index_;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// We're seeking to the key we're already at.</span>
        <span class="hljs-keyword">return</span>;
      }
    }

    <span class="hljs-keyword">while</span> (left &lt; right) {
      <span class="hljs-keyword">uint32_t</span> mid = (left + right + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
      <span class="hljs-keyword">uint32_t</span> region_offset = GetRestartPoint(mid);
      <span class="hljs-keyword">uint32_t</span> shared, non_shared, value_length;
      <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* key_ptr =
          DecodeEntry(data_ + region_offset, data_ + restarts_, &amp;shared,
                      &amp;non_shared, &amp;value_length);
      <span class="hljs-keyword">if</span> (key_ptr == <span class="hljs-literal">nullptr</span> || (shared != <span class="hljs-number">0</span>)) {
        CorruptionError();
        <span class="hljs-keyword">return</span>;
      }
      <span class="hljs-function">Slice <span class="hljs-title">mid_key</span><span class="hljs-params">(key_ptr, non_shared)</span></span>;
      <span class="hljs-keyword">if</span> (Compare(mid_key, target) &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// Key at "mid" is smaller than "target".  Therefore all</span>
        <span class="hljs-comment">// blocks before "mid" are uninteresting.</span>
        left = mid;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// Key at "mid" is &gt;= "target".  Therefore all blocks at or</span>
        <span class="hljs-comment">// after "mid" are uninteresting.</span>
        right = mid - <span class="hljs-number">1</span>;
      }
    }

    <span class="hljs-comment">// We might be able to use our current position within the restart block.</span>
    <span class="hljs-comment">// This is true if we determined the key we desire is in the current block</span>
    <span class="hljs-comment">// and is after than the current key.</span>
    assert(current_key_compare == <span class="hljs-number">0</span> || Valid());
    <span class="hljs-keyword">bool</span> skip_seek = left == restart_index_ &amp;&amp; current_key_compare &lt; <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (!skip_seek) {
      SeekToRestartPoint(left);
    }
    <span class="hljs-comment">// Linear search (within restart block) for first key &gt;= target</span>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
      <span class="hljs-keyword">if</span> (!ParseNextKey()) {
        <span class="hljs-keyword">return</span>;
      }
      <span class="hljs-keyword">if</span> (Compare(key_, target) &gt;= <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span>;
      }
    }
  }
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ParseNextKey</span><span class="hljs-params">()</span> </span>{
    current_ = NextEntryOffset();
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* p = data_ + current_;
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* limit = data_ + restarts_;  <span class="hljs-comment">// Restarts come right after data</span>
    <span class="hljs-keyword">if</span> (p &gt;= limit) {
      <span class="hljs-comment">// No more entries to return.  Mark as invalid.</span>
      current_ = restarts_;
      restart_index_ = num_restarts_;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-comment">// Decode next entry</span>
    <span class="hljs-keyword">uint32_t</span> shared, non_shared, value_length;
    p = DecodeEntry(p, limit, &amp;shared, &amp;non_shared, &amp;value_length);
    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span> || key_.size() &lt; shared) {
      CorruptionError();
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    } <span class="hljs-keyword">else</span> {
      key_.resize(shared);
      key_.append(p, non_shared);
      value_ = Slice(p + non_shared, value_length);
      <span class="hljs-keyword">while</span> (restart_index_ + <span class="hljs-number">1</span> &lt; num_restarts_ &amp;&amp;
             GetRestartPoint(restart_index_ + <span class="hljs-number">1</span>) &lt; current_) {
        ++restart_index_;
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
  }
</code></pre>
<p>首先在重启点列表中进行二分查找，定位到比target小的最近的一个重启点，然后在该重启点开始顺序解析Entry（KV数据）进行查找比较，直到找到为止</p>
<h4 id="filterblockreader-">FilterBlockReader结构</h4>
<p>很简单，没什么好写的</p>
<h2 id="sstable-">SSTable的写入和读取</h2>
<h3 id="tablebuilder">TableBuilder</h3>
<pre><code class="lang-cpp">void TableBuilder::Add(const Slice&amp; key, const Slice&amp; value) {
  Rep* r = rep_;
  <span class="hljs-function"><span class="hljs-title">assert</span>(!r-&gt;</span>closed);
  <span class="hljs-keyword">if</span> (!ok()) return;
  <span class="hljs-function"><span class="hljs-title">if</span> (r-&gt;</span>num_entries &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-function"><span class="hljs-title">assert</span>(r-&gt;</span><span class="hljs-function"><span class="hljs-title">options</span>.comparator-&gt;</span>C<span class="hljs-function"><span class="hljs-title">ompare</span>(key, Slice(r-&gt;</span>last_key)) &gt; <span class="hljs-number">0</span>);
  }

  <span class="hljs-function"><span class="hljs-title">if</span> (r-&gt;</span>pending_index_entry) {
    <span class="hljs-function"><span class="hljs-title">assert</span>(r-&gt;</span>data_block.empty());
    <span class="hljs-function"><span class="hljs-title">r</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">options</span>.comparator-&gt;</span>F<span class="hljs-function"><span class="hljs-title">indShortestSeparator</span>(&amp;r-&gt;</span>last_key, key);
    std::string handle_encoding;
    <span class="hljs-function"><span class="hljs-title">r</span>-&gt;</span>pending_handle.EncodeTo(&amp;handle_encoding);
    <span class="hljs-function"><span class="hljs-title">r</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">index_block</span>.Add(r-&gt;</span>last_key, Slice(handle_encoding));
    <span class="hljs-function"><span class="hljs-title">r</span>-&gt;</span>pending_index_entry = <span class="hljs-literal">false</span>;
  }

  <span class="hljs-function"><span class="hljs-title">if</span> (r-&gt;</span>filter_block != nullptr) {
    <span class="hljs-function"><span class="hljs-title">r</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">filter_block</span>-&gt;</span>AddKey(key);
  }

  <span class="hljs-function"><span class="hljs-title">r</span>-&gt;</span>last_key.assign(key.<span class="hljs-keyword">data</span>(), key.size());
  <span class="hljs-function"><span class="hljs-title">r</span>-&gt;</span>num_entries++;
  <span class="hljs-function"><span class="hljs-title">r</span>-&gt;</span>data_block.Add(key, value);

  <span class="hljs-function"><span class="hljs-title">const</span> size_t estimated_block_size = r-&gt;</span>data_block.CurrentSizeEstimate();
  <span class="hljs-function"><span class="hljs-title">if</span> (estimated_block_size &gt;= r-&gt;</span>options.block_size) {
    Flush();
  }
}
</code></pre>
<p>当调用SSTable的Add(k，v)方法添加一条KV数据时，首先会将该数据依次加入Data Block和Filter Block中，添加完成后再判定当前的Data Block大小是否已经大于设定的阈值了。如果大于阈值则会调用Flush()方法将当前的Data Block写入SSTable文件并清空(block-&gt;reset())Data Block，同时将pending_index_entry的值设为true。当下一条KV数据再进来时会命中该值为true的逻辑，然后往Index Block中追加一条索引信息，追加完成后再将其重新置回false</p>
<pre><code class="lang-cpp">Status TableBuilder::Finish() {
  Rep* r = rep_;
  Flush();
  <span class="hljs-function"><span class="hljs-title">assert</span>(!r-&gt;</span>closed);
  <span class="hljs-function"><span class="hljs-title">r</span>-&gt;</span>closed = <span class="hljs-literal">true</span>;

  BlockHandle filter_block_handle, metaindex_block_handle, index_block_handle;

  <span class="hljs-comment">// Write filter block</span>
  <span class="hljs-function"><span class="hljs-title">if</span> (ok() &amp;&amp; r-&gt;</span>filter_block != nullptr) {
    W<span class="hljs-function"><span class="hljs-title">riteRawBlock</span>(r-&gt;</span><span class="hljs-function"><span class="hljs-title">filter_block</span>-&gt;</span>Finish(), kNoCompression,
                  &amp;filter_block_handle);
  }

  <span class="hljs-comment">// Write metaindex block</span>
  <span class="hljs-keyword">if</span> (ok()) {
    B<span class="hljs-function"><span class="hljs-title">lockBuilder</span> meta_index_block(&amp;r-&gt;</span>options);
    <span class="hljs-function"><span class="hljs-title">if</span> (r-&gt;</span>filter_block != nullptr) {
      <span class="hljs-comment">// Add mapping from "filter.Name" to location of filter data</span>
      std::string key = <span class="hljs-string">"filter."</span>;
      <span class="hljs-function"><span class="hljs-title">key</span>.append(r-&gt;</span><span class="hljs-function"><span class="hljs-title">options</span>.filter_policy-&gt;</span>Name());
      std::string handle_encoding;
      filter_block_handle.EncodeTo(&amp;handle_encoding);
      meta_index_block.Add(key, handle_encoding);
    }

    <span class="hljs-comment">// TODO(postrelease): Add stats and other meta blocks</span>
    WriteBlock(&amp;meta_index_block, &amp;metaindex_block_handle);
  }

  <span class="hljs-comment">// Write index block</span>
  <span class="hljs-keyword">if</span> (ok()) {
    <span class="hljs-function"><span class="hljs-title">if</span> (r-&gt;</span>pending_index_entry) {
      <span class="hljs-function"><span class="hljs-title">r</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">options</span>.comparator-&gt;</span>F<span class="hljs-function"><span class="hljs-title">indShortSuccessor</span>(&amp;r-&gt;</span>last_key);
      std::string handle_encoding;
      <span class="hljs-function"><span class="hljs-title">r</span>-&gt;</span>pending_handle.EncodeTo(&amp;handle_encoding);
      <span class="hljs-function"><span class="hljs-title">r</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">index_block</span>.Add(r-&gt;</span>last_key, Slice(handle_encoding));
      <span class="hljs-function"><span class="hljs-title">r</span>-&gt;</span>pending_index_entry = <span class="hljs-literal">false</span>;
    }
    W<span class="hljs-function"><span class="hljs-title">riteBlock</span>(&amp;r-&gt;</span>index_block, &amp;index_block_handle);
  }

  <span class="hljs-comment">// Write footer</span>
  <span class="hljs-keyword">if</span> (ok()) {
    Footer footer;
    footer.set_metaindex_handle(metaindex_block_handle);
    footer.set_index_handle(index_block_handle);
    std::string footer_encoding;
    footer.EncodeTo(&amp;footer_encoding);
    <span class="hljs-function"><span class="hljs-title">r</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">status</span> = r-&gt;</span><span class="hljs-function"><span class="hljs-title">file</span>-&gt;</span>Append(footer_encoding);
    <span class="hljs-function"><span class="hljs-title">if</span> (r-&gt;</span>status.ok()) {
      <span class="hljs-function"><span class="hljs-title">r</span>-&gt;</span>offset += footer_encoding.size();
    }
  }
  <span class="hljs-function"><span class="hljs-title">return</span> r-&gt;</span>status;
}
</code></pre>
<p>就是按SSTable的结构将每部分Block追加写入文件而已</p>
<h3 id="table">Table</h3>
<p>读取靠Table的Iter完成</p>
<pre><code class="lang-cpp">Status Table::Open(<span class="hljs-keyword">const</span> Options&amp; options, RandomAccessFile* file,
                   uint64_t size, Table** table) {
  *table = nullptr;
  <span class="hljs-keyword">if</span> (size &lt; Footer::kEncodedLength) {
    <span class="hljs-keyword">return</span> Status::Corruption(<span class="hljs-string">"file is too short to be an sstable"</span>);
  }

  <span class="hljs-keyword">char</span> footer_space[Footer::kEncodedLength];
  Slice footer_input;
  Status s = file-&gt;Read(size - Footer::kEncodedLength, Footer::kEncodedLength,
                        &amp;footer_input, footer_space);
  <span class="hljs-keyword">if</span> (!s.ok()) <span class="hljs-keyword">return</span> s;

  Footer footer;
  s = footer.DecodeFrom(&amp;footer_input);
  <span class="hljs-keyword">if</span> (!s.ok()) <span class="hljs-keyword">return</span> s;

  <span class="hljs-comment">// Read the index block</span>
  BlockContents index_block_contents;
  ReadOptions opt;
  <span class="hljs-keyword">if</span> (options.paranoid_checks) {
    opt.verify_checksums = <span class="hljs-keyword">true</span>;
  }
  s = ReadBlock(file, opt, footer.index_handle(), &amp;index_block_contents);

  <span class="hljs-keyword">if</span> (s.ok()) {
    <span class="hljs-comment">// We've successfully read the footer and the index block: we're</span>
    <span class="hljs-comment">// ready to serve requests.</span>
    Block* index_block = <span class="hljs-keyword">new</span> Block(index_block_contents);
    Rep* rep = <span class="hljs-keyword">new</span> Table::Rep;
    rep-&gt;options = options;
    rep-&gt;file = file;
    rep-&gt;metaindex_handle = footer.metaindex_handle();
    rep-&gt;index_block = index_block;
    rep-&gt;cache_id = (options.block_cache ? options.block_cache-&gt;NewId() : <span class="hljs-number">0</span>);
    rep-&gt;filter_data = nullptr;
    rep-&gt;filter = nullptr;
    *table = <span class="hljs-keyword">new</span> Table(rep);
    (*table)-&gt;ReadMeta(footer);
  }

  <span class="hljs-keyword">return</span> s;
}
</code></pre>
<p>首先读取Footer,根据Footer存储的Meta Index Block和Index Block的索引信息，依次调用ReadBlock读取数据，读取索引信息后进一步调用ReadFilter读取FilterBlock中布隆过滤器的数据，然后就可以处理查询请求了。在查询时SSTable对外通过TwoLevelIterator迭代器来查找。该迭代器创建时需要传递两个迭代器：一个是Index Block的迭代器，另一个是Data Block的迭代器。这也是TwoLevelIterator名称的由来。</p>
<h2 id="sstable-">SSTable读取全过程</h2>
<p>入口是Version::Get()</p>
<pre><code class="lang-cpp">Status Version::Get(const ReadOptions&amp; options, const LookupKey&amp; k,
                    std::string* value, GetStats* stats) {
  stats-&gt;seek_file = nullptr;
  stats-&gt;seek_file_level = -<span class="hljs-number">1</span>;

  struct State {
    Saver saver;
    GetStats* stats;
    const ReadOptions* options;
    Slice ikey;
    FileMetaData* last_file_read;
    int last_file_read_level;

    VersionSet* vset;
    Status s;
    bool found;
    //从第level层的第f个文件开始判断是否匹配  
    static bool Match(void* arg, int level, FileMetaData* f) {
      State* <span class="hljs-keyword">state</span> = reinterpret_cast<span class="hljs-variable">&lt;State*&gt;</span>(arg);

      if (state-&gt;stats-&gt;seek_file == nullptr &amp;&amp;
          state-&gt;last_file_read != nullptr) {
        // We have had more than one seek <span class="hljs-keyword">for</span> this read.  Charge the <span class="hljs-number">1</span>st file.
        state-&gt;stats-&gt;seek_file = state-&gt;last_file_read;
        state-&gt;stats-&gt;seek_file_level = state-&gt;last_file_read_level;
      }

      state-&gt;last_file_read = f;
      state-&gt;last_file_read_level = level;
      //从SSTable的缓存中查找，其中Savlue是个函数  
      state-&gt;s = state-&gt;vset-&gt;table_cache_-&gt;Get(*state-&gt;options, f-&gt;number,
                                                f-&gt;file_size, state-&gt;ikey,
                                                &amp;state-&gt;saver, SaveValue);
      if (!state-&gt;s.ok()) {
        state-&gt;found = true;
        return false;
      }
      switch (state-&gt;saver.<span class="hljs-keyword">state</span>) {
        case kNotFound:
          return true;  // Keep searching <span class="hljs-keyword">in</span> other files
        case kFound:
          state-&gt;found = true;
          return false;
        case kDeleted:
          return false;
        case kCorrupt:
          state-&gt;s =
              Status::Corruption(<span class="hljs-string">"corrupted key for "</span>, state-&gt;saver.user_key);
          state-&gt;found = true;
          return false;
      }

      // Not reached. Added <span class="hljs-keyword">to</span> avoid false compilation warnings of
      // <span class="hljs-string">"control reaches end of non-void function"</span>.
      return false;
    }
  };

  State <span class="hljs-keyword">state</span>;
  <span class="hljs-keyword">state</span>.found = false;
  <span class="hljs-keyword">state</span>.stats = stats;
  <span class="hljs-keyword">state</span>.last_file_read = nullptr;
  <span class="hljs-keyword">state</span>.last_file_read_level = -<span class="hljs-number">1</span>;

  <span class="hljs-keyword">state</span>.options = &amp;options;
  <span class="hljs-keyword">state</span>.ikey = k.internal_key();
  <span class="hljs-keyword">state</span>.vset = vset_;

  <span class="hljs-keyword">state</span>.saver.<span class="hljs-keyword">state</span> = kNotFound;
  <span class="hljs-keyword">state</span>.saver.ucmp = vset_-&gt;icmp_.user_comparator();
  <span class="hljs-keyword">state</span>.saver.user_key = k.user_key();
  <span class="hljs-keyword">state</span>.saver.value = value;
  //遍历所有层的SSTable
  ForEachOverlapping(<span class="hljs-keyword">state</span>.saver.user_key, <span class="hljs-keyword">state</span>.ikey, &amp;<span class="hljs-keyword">state</span>, &amp;State::Match);

  return <span class="hljs-keyword">state</span>.found ? <span class="hljs-keyword">state</span>.s : Status::NotFound(Slice());
}
</code></pre>
<pre><code class="lang-cpp"><span class="hljs-keyword">void</span> Version::ForEachOverlapping(Slice user_key, Slice internal_key, <span class="hljs-keyword">void</span>* arg,
                                 <span class="hljs-keyword">bool</span> (*func)(<span class="hljs-keyword">void</span>*, <span class="hljs-keyword">int</span>, FileMetaData*)) {
  <span class="hljs-keyword">const</span> Comparator* ucmp = vset_-&gt;icmp_.user_comparator();

  <span class="hljs-comment">// Search level-0 in order from newest to oldest.</span>
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;FileMetaData*&gt; tmp;
  tmp.reserve(files_[<span class="hljs-number">0</span>].size());
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; files_[<span class="hljs-number">0</span>].size(); i++) {
    FileMetaData* f = files_[<span class="hljs-number">0</span>][i];
    <span class="hljs-keyword">if</span> (ucmp-&gt;Compare(user_key, f-&gt;smallest.user_key()) &gt;= <span class="hljs-number">0</span> &amp;&amp;
        ucmp-&gt;Compare(user_key, f-&gt;largest.user_key()) &lt;= <span class="hljs-number">0</span>) {
      tmp.push_back(f);
    }
  }
  <span class="hljs-keyword">if</span> (!tmp.empty()) {
    <span class="hljs-comment">//从新到旧排序</span>
    <span class="hljs-built_in">std</span>::sort(tmp.begin(), tmp.end(), NewestFirst);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; tmp.size(); i++) {
      <span class="hljs-keyword">if</span> (!(*func)(arg, <span class="hljs-number">0</span>, tmp[i])) {
        <span class="hljs-keyword">return</span>;
      }
    }
  }

  <span class="hljs-comment">// Search other levels.</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> level = <span class="hljs-number">1</span>; level &lt; config::kNumLevels; level++) {
    <span class="hljs-keyword">size_t</span> num_files = files_[level].size();
    <span class="hljs-keyword">if</span> (num_files == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;

    <span class="hljs-comment">// Binary search to find earliest index whose largest key &gt;= internal_key.</span>
    <span class="hljs-keyword">uint32_t</span> index = FindFile(vset_-&gt;icmp_, files_[level], internal_key);
    <span class="hljs-keyword">if</span> (index &lt; num_files) {
      FileMetaData* f = files_[level][index];
      <span class="hljs-keyword">if</span> (ucmp-&gt;Compare(user_key, f-&gt;smallest.user_key()) &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// All of "f" is past any data for user_key</span>
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (!(*func)(arg, level, f)) {
          <span class="hljs-keyword">return</span>;
        }
      }
    }
  }
}
<span class="hljs-comment">//在一个层的files中通过二分查找定位到某个SSTable文件</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FindFile</span><span class="hljs-params">(<span class="hljs-keyword">const</span> InternalKeyComparator&amp; icmp,
             <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;FileMetaData*&gt;&amp; files, <span class="hljs-keyword">const</span> Slice&amp; key)</span> </span>{
  <span class="hljs-keyword">uint32_t</span> left = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">uint32_t</span> right = files.size();
  <span class="hljs-keyword">while</span> (left &lt; right) {
    <span class="hljs-keyword">uint32_t</span> mid = (left + right) / <span class="hljs-number">2</span>;
    <span class="hljs-keyword">const</span> FileMetaData* f = files[mid];
    <span class="hljs-keyword">if</span> (icmp.InternalKeyComparator::Compare(f-&gt;largest.Encode(), key) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// Key at "mid.largest" is &lt; "target".  Therefore all</span>
      <span class="hljs-comment">// files at or before "mid" are uninteresting.</span>
      left = mid + <span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// Key at "mid.largest" is &gt;= "target".  Therefore all files</span>
      <span class="hljs-comment">// after "mid" are uninteresting.</span>
      right = mid;
    }
  }
  <span class="hljs-keyword">return</span> right;
}
</code></pre>
<p>在上述查找过程中，首先调用ForEachOverlapping在所有层开始查找。具体过程是，首先在level 0层按照文件新旧的顺序逐个查找（因为level0层的SSTable之间的数据有可能相互重叠），只要找到就结束查找。当level 0层没有找到时，在剩下的层开始逐层查找。level 0层之外的其他层的多个SSTable中的数据是不重叠的，因此待查找的key只会命中其中一个SSTable文件。这也是FindFile中通过二分查找、利用每个SSTable文件保存的最大值来定位SSTable文件的逻辑。当找到该文件后，再在该文件中查找。单个SSTable的具体查找过程实际上是在Match方法中完成的</p>
<h2 id="compact-">Compact的实现分析</h2>
<blockquote>
<p>[!NOTE]</p>
<p>累了，不搞了</p>
</blockquote>
